## 垃圾收集

&emsp;&emsp;Java的垃圾收集主要是针对Java堆和方法区。

### 1.对象死亡判定

#### 1.1 引用计数法
&emsp;&emsp;在对象中添加一个引用计数器，每当有一个地方引用它时，，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可再被使用的。但是，引用计数器不能解决对象之间相互依循环引用的问题。

#### 1.2 可达性分析
&emsp;&emsp;这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者说从GC Roots到这个对象不可达时，说明此对象是不可能再被使用的。

&emsp;&emsp;在Java中，固定可作为GC Roots的对象包括以下几种：

* 在虚拟机栈（栈帧中的本地变量表）中引用的对象，比如各个线程被调用的方法堆栈中使用的参数、局部变量、临时变量等。
* 在方法区中类静态属性引用的对象，比如Java类的引用类型静态变量。
* 在方法区中常量引用的对象，比如字符串常量池（String Table）里的引用。
* 在本地方法栈中JNI（通常所说的Native方法）引用的对象。
* Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException、OutOfMemoryError）等，还有系统类加载器。
* 所有被同步锁（synchronize关键字）持有的对象。
* 反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

&emsp;&emsp;除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整的GC Roots集合。

#### 1.3 对象引用
&emsp;&emsp;引用定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据代表某块内存、某个对象的引用。

#### 1.4 生存还是死亡
&emsp;&emsp;即使在可达性分析算法中判定不可达的对象，也不是“非死不可”，这时候它们暂时还处于“缓刑阶段”，要宣告一个对象死亡，至少要经历两次标记过程；如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。

&emsp;&emsp;在JDK1.2版本之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种。

### 2. 垃圾回收算法
#### 2.1 分代收集理论

#### 2.2 标记-清除算法

&emsp;&emsp;算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，完成后，统一回收掉所有被标记的对象。

&emsp;&emsp;两个缺点，第一，执行效率不稳定。如果java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率随着对象数量的增长而降低；第二，内存空间的碎片化。

#### 2.3 标记-复制算法

&emsp;&emsp;把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。 发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上。

#### 2.4 标记-整理算法
&emsp;&emsp;

### 3.经典垃圾收集器

#### 3.1 Serial收集器

#### 3.2 ParNew收集器

#### 3.3 Parallel Scavenge收集器

#### 3.4 Serial Old收集器

#### 3.4 Parallel Old收集器

#### 3.5 CMS收集器

#### 3.6 G1收集器

### 4.低延迟垃圾收集器

#### 4.1 Schenandoah收集器

#### 4.2 ZGC收集器
