## 1. 对象的创建

### 1.1  对象创建

&emsp;&emsp;当Java虚拟机遇到一条字节码new指令时，首先去检查这个指令的参数是否在**常量池**中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

### 1.2 内存分配

&emsp;&emsp;对象所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。分配方式有两种：**指针碰撞**和**空闲列表**。

&emsp;&emsp;指针碰撞：假设Java堆中内存是绝对规整的，所有被使用过的内存都放在一边，空闲的放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离。

&emsp;&emsp;空闲列表：如果Java堆中的内存并不是规整的，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

### 1.3 内存分配选择

&emsp;&emsp;选择哪种内存分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩的能力决定。因此，当时用Seria、ParNew等带有压缩整理过程的收集器时，系统采用**指针碰撞**算法；当使用CMS这种基础清除算法的收集器时，理论上只能采用**空闲列表**来分配内存。

## 2. 对象的内存布局
### 2.1 存储布局

&emsp;&emsp;在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

### 2.2 对象头

 &emsp;&emsp;HotSpot虚拟机对象的对象头包括两类信息。第一类用于存储对象自身的的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏线程ID、偏向时间戳等。这部分数据的长度在32位和64位虚拟机中分别为32个比特和64个比特，称作“Mark Word”。对象需要存储的运行时数据很多，已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存存储尽量多的数据，根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容为：

| 存储内容                             | 标志位 | 状态               |
| ------------------------------------ | ------ | ------------------ |
| 对象哈希码、对象分代年龄             | 01     | 未锁定             |
| 指向锁记录的指针                     | 00     | 轻量级锁定         |
| 指向重量级锁的指针                   | 10     | 膨胀（重量级锁定） |
| 空、不需要记录信息                   | 11     | GC标记             |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01     | 可偏向             |

&emsp;&emsp;对象头的另一部分时类型指针，即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。

### 2.3 实例数据

&emsp;&emsp;实例数据部分时对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（-XX:FieldsAllocationStyle）和字段在Java源码中定义的顺序影响。默认分配顺序为longs/doubles、ints、shorts/chars、bytes/boolean、oops（Ordinary Object Pointers）。

### 2.4 对齐填充

 &emsp;&emsp;这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8个字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。
